import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

/**
 * <h1> Board </h1>
 * The Board class is playground of this game, every player will located on a specific Square of Board
 * The board could be instantiated by a config file
 *
 * @author David Ji
 * @since 2018-5-26
 *
 */
class Board {
    /** This is capacity of board, also is finish point */
    private int capacity;

    /** This is used store all information of Squares */
    private List<Square> Squares;

    /**
     * board will be initialized by config file
     * @param FileName this is config file's name
     * */
    Board(String FileName) {
        initialize(FileName);
    }

    /**
     * Read board's information and initialize every square
     * @param filePath this is config file's path
     */
    private void initialize(String filePath) {
        try {
            File file = new File(filePath);
            // first line means what size of this game board
            Scanner sc = new Scanner(file);
            this.capacity = Integer.parseInt(sc.nextLine());

            // initialize every square and index base on 1
            this.Squares = new ArrayList<>(capacity + 1);

            // add start square into board
            Squares.add(new Square(0,0, SquareType.START));

            while (sc.hasNextLine()) {
                String curLine = sc.nextLine();
                Squares.add(createSquare(curLine));
            }

        } catch(IOException ex) {
            System.err.println("Please check your file!");
            ex.printStackTrace();
            System.exit(1);
        }
    }

    /**
     * Each line of input means each square of Board
     * <p> There is three kinds of state: </p>
     * <ol>
     *     <li> Normal: not any picture just a number means current position. eg. 5 </li>
     *     <li> Ladder: first number smaller than second number eg. 3 -- 5 </li>
     *     <li> Chute: first number bigger than second number eg. 2 -- 7 </li>
     * </ol>
     * @param line every line of config file
     * @return this method will return a new instance of Square
     */
    private Square createSquare(String line) {
        int flag = line.indexOf("-->");

        // number -> current position
        if (flag== -1) {
            int curPos = Integer.parseInt(line);
            return new Square(curPos,curPos,SquareType.NORMAL);
        }

        int curPos = Integer.parseInt(line.substring(0, flag));
        int nextPos = Integer.parseInt(line.substring(flag + 3, line.length()));

        // ladder
        if (curPos < nextPos) {
            return new Square(curPos,nextPos,SquareType.LADDER);
        }

        // chute
        else {
            return new Square(curPos,nextPos,SquareType.CHUTE);
        }
    }

    /**
     * @return all capacity of this board
     */
    int getCapacity() {
        return capacity;
    }

    /**
     * @return all Squares in this board
     */
    List<Square> getSquares() {
        return Squares;
    }

    /**
     * This method is used for get all following Squares until next Square is normal Square
     * <p>
     *     if there is multiple ladder or chute, we should send player to last destination
     * </p>
     *
     * @param cur this is current Square
     * @param step this is random value generated by spin
     * @return this is detail of every step from begin to end
     */
    LinkedList<Square> getNextAllSquares(Square cur, int step) {
        LinkedList<Square> allSquares = new LinkedList<>();
        int nextPos = cur.getCurrentPos() + step;

        // if next position equals exact finish point
        if (nextPos  == capacity) {
            allSquares.add(Squares.get(capacity));
        }
        // if next position exceed finish point will stay and wait for next turn
        else if (nextPos > capacity) {
            allSquares.add(cur);
        } else {
            nextSquares(Squares.get(nextPos), allSquares);
        }
        return allSquares;
    }

    /**
     * This method is used for helping getNextAllSquares() to collect every step
     * <b>Note: </b> recursively solve this until next Square's type equals NORMAL
     * @param cur   this is current Square
     * @param squares add all steps into list
     */
    private void nextSquares(Square cur, LinkedList<Square> squares) {
        // add cur Square into list
        squares.add(cur);

        // if next position neither chute nor ladder, add it into next Squares
        if (cur.getType() == SquareType.NORMAL) {
            return;
        }

        // get Next Square and recursively solve this
        Square nextSquare = this.getSquares().get(cur.getNextPos());
        nextSquares(nextSquare, squares);
    }
}
